<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>kahvi's newsletter analysis</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect x='4' y='18' width='5' height='10' rx='1' fill='%23f0883e'/><rect x='13' y='10' width='5' height='18' rx='1' fill='%23f0883e'/><rect x='22' y='4' width='5' height='24' rx='1' fill='%23f0883e'/></svg>">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    :root { --accent: #f0883e; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0d1117;
      color: #c9d1d9;
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      font-size: 14px;
      padding: 24px;
    }
    h1 { color: var(--accent); font-size: 22px; margin-bottom: 8px; }
    h2 {
      color: #8b949e;
      font-size: 15px;
      font-weight: 500;
      margin-bottom: 12px;
      border-bottom: 1px solid #21262d;
      padding-bottom: 6px;
    }
    .section-title {
      color: var(--accent);
      font-size: 16px;
      margin-top: 26px;
      margin-bottom: 4px;
      border-bottom: 1px solid #21262d;
      padding-bottom: 6px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(560px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .card {
      background: #161b22;
      border: 1px solid #21262d;
      border-radius: 6px;
      padding: 16px;
    }
    .card.full { grid-column: 1 / -1; }
    canvas { max-height: 340px; }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      text-align: left;
      padding: 6px 10px;
      border-bottom: 1px solid #21262d;
    }
    th { color: #8b949e; font-weight: 500; }
    td { color: #c9d1d9; }
    tr:hover td { background: #1c2128; }
    .stat-row {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .stat {
      background: #161b22;
      border: 1px solid #21262d;
      border-radius: 6px;
      padding: 12px 18px;
    }
    .stat .label { color: #8b949e; font-size: 12px; }
    .stat .value { color: var(--accent); font-size: 20px; font-weight: 600; }
    .loading { color: #8b949e; padding: 40px; text-align: center; }
    .opening-line { max-width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .error-text { color: #f85149; }
    .description { color: #8b949e; font-size: 12px; margin: -6px 0 12px 0; }
    .post-links {
      background: #161b22;
      border: 1px solid #21262d;
      border-radius: 6px;
      padding: 10px 14px;
      margin-bottom: 16px;
    }
    .post-links summary {
      color: var(--accent);
      cursor: pointer;
      font-size: 13px;
      user-select: none;
    }
    .post-links summary:hover { color: color-mix(in srgb, var(--accent), white 25%); }
    .post-links-list {
      list-style: none;
      margin-top: 10px;
      columns: 2;
      column-gap: 32px;
    }
    @media (max-width: 700px) { .post-links-list { columns: 1; } }
    .post-links-list li { padding: 2px 0; }
    .post-links-list a {
      color: #c9d1d9;
      text-decoration: none;
      font-size: 13px;
    }
    .post-links-list a:hover { color: var(--accent); text-decoration: underline; }
    .post-links-list .post-date { color: #484f58; font-size: 12px; margin-left: 6px; }
    .year-btn {
      background: #21262d;
      color: #c9d1d9;
      border: 1px solid #30363d;
      border-radius: 4px;
      padding: 4px 14px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      margin-right: 4px;
    }
    .year-btn:hover { background: #30363d; }
    .year-btn.active { background: var(--accent); color: #0d1117; border-color: var(--accent); }
  </style>
</head>
<body>
  <h1>kahvi's newsletter analysis</h1>
  <p id="subtitle" style="color: #8b949e; margin-bottom: 8px;"></p>
  <div style="margin-bottom: 16px;">
    <a href="/newsletter-analysis/compare" style="color: #8b949e; text-decoration: none; font-size: 13px;">Compare years â†’</a>
  </div>

  <div id="yearFilter" style="margin-bottom: 16px;">
    <label style="color: #8b949e; margin-right: 8px;">Filter by year:</label>
    <button class="year-btn active" data-year="all">All</button>
    <button class="year-btn" data-year="2023">2023</button>
    <button class="year-btn" data-year="2024">2024</button>
    <button class="year-btn" data-year="2025">2025</button>
  </div>

  <details id="postLinks" class="post-links">
    <summary id="postLinksSummary">Posts (0)</summary>
    <ul id="postLinksContent" class="post-links-list"></ul>
  </details>

  <div id="stats" class="stat-row"></div>

  <h2 class="section-title">Post & Monthly Trends</h2>
  <div class="grid" id="mainGrid">
    <div class="card">
      <h2>Word Count (Per Post)</h2>
      <canvas id="wordCountChart"></canvas>
    </div>

    <div class="card">
      <h2>Monthly Word Volume</h2>
      <p class="description">Total words per month with 3-month moving average.</p>
      <canvas id="monthlyWordChart"></canvas>
    </div>

    <div class="card">
      <h2>Monthly Post Count</h2>
      <canvas id="postCountChart"></canvas>
    </div>

    <div class="card">
      <h2>Readability (Per Post, Flesch-Kincaid Grade)</h2>
      <canvas id="readabilityChart"></canvas>
    </div>

    <div class="card">
      <h2>Readability Trend (Monthly Avg)</h2>
      <canvas id="readabilityMonthlyChart"></canvas>
    </div>

    <div class="card">
      <h2>Sentiment Trend (Monthly Avg)</h2>
      <p class="description">Comparative AFINN score; above zero is more positive.</p>
      <canvas id="sentimentChart"></canvas>
    </div>

    <div class="card">
      <h2>Sentence Length Trends</h2>
      <canvas id="sentenceLengthChart"></canvas>
    </div>

    <div class="card">
      <h2>Question Density</h2>
      <canvas id="questionDensityChart"></canvas>
    </div>

    <div class="card">
      <h2>List vs Prose Ratio</h2>
      <canvas id="listProseChart"></canvas>
    </div>

    <div class="card">
      <h2>Vocabulary Growth</h2>
      <canvas id="vocabGrowthChart"></canvas>
    </div>

    <div class="card full">
      <h2>Named Entity Tracker (Top Entities Over Time)</h2>
      <canvas id="entityChart"></canvas>
    </div>

    <div class="card full">
      <h2>Seasonality Index (Recurring Patterns)</h2>
      <p class="description">Index 100 = overall average across all years. Shows recurring monthly patterns in words, sentiment, and readability.</p>
      <canvas id="seasonalityChart"></canvas>
    </div>

    <div class="card">
      <h2>Self-References</h2>
      <p class="description">Links pointing back to newsletter.kahvipatel.com -- how often each post references previous newsletters.</p>
      <canvas id="selfRefChart"></canvas>
    </div>

    <div class="card full">
      <h2>Days Late</h2>
      <p class="description">Days after the end of the covered month that each newsletter was posted.</p>
      <canvas id="daysLateChart"></canvas>
    </div>

    <div class="card" id="deliveriesCard">
      <h2>Deliveries vs Opens (Substack)</h2>
      <canvas id="deliveriesChart"></canvas>
    </div>

    <div class="card" id="openRateCard">
      <h2>Open Rate (Substack)</h2>
      <canvas id="openRateChart"></canvas>
    </div>

    <div class="card" id="firstOpenCard">
      <h2>Time to First Open (Minutes)</h2>
      <canvas id="firstOpenChart"></canvas>
    </div>

    <div class="card" id="subscriberCard">
      <h2>Subscriber Growth</h2>
      <canvas id="subscriberGrowthChart"></canvas>
    </div>

    <div class="card full" id="openCountriesCard">
      <h2>Top Open Countries</h2>
      <canvas id="openCountriesChart"></canvas>
    </div>

    <div class="card full">
      <h2>Publication Timeline</h2>
      <p class="description">When each newsletter was actually sent, with subject line and subtitle.</p>
      <div style="max-height: 500px; overflow-y: auto;">
        <table id="publicationTable">
          <thead><tr><th>Post</th><th>Subtitle</th><th>Posted</th><th>Days Since Last</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card full">
      <h2>Opening Lines</h2>
      <div style="max-height: 400px; overflow-y: auto;">
        <table id="openingLinesTable">
          <thead><tr><th>Post</th><th>Opening Line</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card full" id="linkRotCard" style="display: none;">
      <h2>Broken Links</h2>
      <div style="max-height: 400px; overflow-y: auto;">
        <table id="linkRotTable">
          <thead><tr><th>URL</th><th>Status</th><th>Source</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // Maximally distinct hues for entity tracker lines
    const COLORS = [
      '#ff4444', '#00ccff', '#ffcc00', '#44ff44', '#ff44ff',
      '#ff8800', '#4488ff', '#88ff00', '#ff0088', '#00ffaa',
      '#aa44ff', '#ffff44', '#44ffff', '#ff6644', '#88aaff',
    ];

    function shortName(filename) {
      return filename.replace('.md', '').replace(/-(\d{4}).*$/, ' $1');
    }

    const chartDefaults = {
      responsive: true,
      maintainAspectRatio: true,
      plugins: {
        legend: { labels: { color: '#8b949e', font: { family: 'monospace', size: 11 } } },
      },
      scales: {
        x: { ticks: { color: '#8b949e', font: { family: 'monospace', size: 10 }, maxRotation: 45 }, grid: { color: '#21262d' } },
        y: { ticks: { color: '#8b949e', font: { family: 'monospace', size: 10 } }, grid: { color: '#21262d' } },
      },
    };

    function mergeOpts(overrides) {
      return JSON.parse(JSON.stringify({ ...chartDefaults, ...overrides }));
    }

    let allData = null;
    const activeCharts = [];

    function postYear(p) {
      if (p.date) return p.date.slice(0, 4);
      if (p.postedDate) return p.postedDate.slice(0, 4);
      return null;
    }

    function filterByYear(arr, year, yearFn) {
      if (year === 'all') return arr;
      return arr.filter(item => yearFn(item) === year);
    }

    const MONTH_LABELS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    function monthLabel(key) {
      const [year, month] = key.split('-').map(Number);
      const date = new Date(Date.UTC(year, month - 1, 1));
      return date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
    }

    function filterMonthEntries(monthMap, year) {
      const entries = Object.entries(monthMap || {}).map(([key, value]) => ({ key, value }));
      const filtered = year === 'all' ? entries : entries.filter(e => e.key.startsWith(year));
      return filtered.sort((a, b) => a.key.localeCompare(b.key));
    }

    function monthKeyFromPost(post) {
      const raw = post.date || post.postedDate;
      if (!raw) return null;
      const parsed = new Date(raw);
      if (Number.isNaN(parsed.getTime())) return null;
      return `${parsed.getUTCFullYear()}-${String(parsed.getUTCMonth() + 1).padStart(2, '0')}`;
    }

    function buildMonthlyAggregate(posts, valueFn, mode = 'sum') {
      const buckets = new Map();
      for (const post of posts) {
        const key = monthKeyFromPost(post);
        if (!key) continue;
        const value = valueFn(post);
        if (value === null || value === undefined || Number.isNaN(value)) continue;
        if (!buckets.has(key)) buckets.set(key, { sum: 0, count: 0 });
        const bucket = buckets.get(key);
        bucket.sum += value;
        bucket.count += 1;
      }
      const keys = [...buckets.keys()].sort();
      const values = keys.map(key => {
        const bucket = buckets.get(key);
        if (!bucket || bucket.count === 0) return null;
        if (mode === 'avg') return Math.round((bucket.sum / bucket.count) * 100) / 100;
        if (mode === 'count') return bucket.count;
        return Math.round(bucket.sum * 100) / 100;
      });
      return { keys, labels: keys.map(monthLabel), values };
    }

    function movingAverage(values, windowSize) {
      return values.map((_, index) => {
        const start = Math.max(0, index - windowSize + 1);
        const slice = values.slice(start, index + 1).filter(v => v !== null);
        if (!slice.length) return null;
        const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length;
        return Math.round(avg * 100) / 100;
      });
    }

    function buildSeasonalityIndex(posts, valueFn) {
      const sums = Array(12).fill(0);
      const counts = Array(12).fill(0);
      const allValues = [];
      for (const post of posts) {
        const key = monthKeyFromPost(post);
        if (!key) continue;
        const value = valueFn(post);
        if (value === null || value === undefined || Number.isNaN(value)) continue;
        const monthIndex = Number(key.split('-')[1]) - 1;
        if (monthIndex < 0 || monthIndex > 11) continue;
        sums[monthIndex] += value;
        counts[monthIndex] += 1;
        allValues.push(value);
      }
      const overallAvg = allValues.length
        ? allValues.reduce((sum, val) => sum + val, 0) / allValues.length
        : 0;
      return sums.map((sum, index) => {
        if (!counts[index] || overallAvg === 0) return null;
        const avg = sum / counts[index];
        return Math.round((avg / overallAvg) * 1000) / 10;
      });
    }

    function substackYearFromPost(post) {
      if (post.coverageMonth) return post.coverageMonth.slice(0, 4);
      if (post.postDate) return post.postDate.slice(0, 4);
      if (post.emailSentAt) return post.emailSentAt.slice(0, 4);
      return null;
    }

    function destroyCharts() {
      while (activeCharts.length) activeCharts.pop().destroy();
    }

    function makeChart(id, config) {
      const chart = new Chart(document.getElementById(id), config);
      activeCharts.push(chart);
      return chart;
    }

    function render(year) {
      destroyCharts();
      const data = allData;
      const posts = filterByYear(data.posts, year, postYear);
      const labels = posts.map(p => shortName(p.filename));

      const monthlyWords = buildMonthlyAggregate(posts, p => p.wordCount, 'sum');
      const monthlyWordAvg = movingAverage(monthlyWords.values, 3);
      const monthlyPostCounts = buildMonthlyAggregate(posts, () => 1, 'count');
      const monthlyReadability = buildMonthlyAggregate(posts, p => p.readability, 'avg');
      const monthlySentiment = buildMonthlyAggregate(posts, p => p.sentiment?.comparative, 'avg');

      const seasonalityWords = buildSeasonalityIndex(posts, p => p.wordCount);
      const seasonalityReadability = buildSeasonalityIndex(posts, p => p.readability);
      const seasonalitySentiment = buildSeasonalityIndex(posts, p => p.sentiment?.comparative);

      // Filter vocab growth and entity data by year
      const vg = year === 'all'
        ? data.global.vocabGrowth
        : (data.global.perYearVocabGrowth?.[year] || []);

      // Summary stats
      const totalWords = posts.reduce((s, p) => s + p.wordCount, 0);
      const avgWords = posts.length ? Math.round(totalWords / posts.length) : 0;
      const avgReadability = posts.length ? (posts.reduce((s, p) => s + p.readability, 0) / posts.length).toFixed(1) : '0';
      const totalSelfRefs = posts.reduce((s, p) => s + p.selfReferences, 0);
      const filteredLinkRot = filterByYear(data.global.linkRot, year, l => {
        const match = l.source.match(/(\d{4})/);
        return match ? match[1] : null;
      });

      document.getElementById('subtitle').textContent = `${posts.length} posts analyzed` + (year !== 'all' ? ` (${year})` : '');

      // Post links
      document.getElementById('postLinksSummary').textContent = `Posts (${posts.length})`;
      const linksContainer = document.getElementById('postLinksContent');
      const sortedPosts = [...posts].sort((a, b) => {
        const da = a.postedDate || a.date || '';
        const db = b.postedDate || b.date || '';
        return da.localeCompare(db);
      });
      linksContainer.innerHTML = sortedPosts.map(p => {
        const slug = p.filename.replace('.md', '');
        const url = `https://www.newsletter.kahvipatel.com/p/${slug}`;
        const label = p.subjectLine || shortName(p.filename);
        const dateStr = p.postedDate ? new Date(p.postedDate).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : '';
        return `<li><a href="${url}" target="_blank" rel="noopener">${label}</a>${dateStr ? `<span class="post-date">${dateStr}</span>` : ''}</li>`;
      }).join('');
      const globalVocab = data.global.vocabGrowth?.length ? data.global.vocabGrowth.at(-1).cumulativeUnique : 0;
      document.getElementById('stats').innerHTML = `
        <div class="stat"><div class="label">Total Words</div><div class="value">${totalWords.toLocaleString()}</div></div>
        <div class="stat"><div class="label">Avg Words/Post</div><div class="value">${avgWords.toLocaleString()}</div></div>
        <div class="stat"><div class="label">Avg Grade Level</div><div class="value">${avgReadability}</div></div>
        <div class="stat"><div class="label">Unique Vocab (Year)</div><div class="value">${(vg.length ? vg.at(-1).cumulativeUnique : 0).toLocaleString()}</div></div>
        <div class="stat"><div class="label">Unique Vocab (All)</div><div class="value">${globalVocab.toLocaleString()}</div></div>
        <div class="stat"><div class="label">Self-References</div><div class="value">${totalSelfRefs}</div></div>
      `;

      // 1. Word Count
      makeChart('wordCountChart', {
        type: 'bar',
        data: {
          labels,
          datasets: [{ label: 'Words', data: posts.map(p => p.wordCount), backgroundColor: '#f0883e88', borderColor: '#f0883e', borderWidth: 1 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } } }),
      });

      // 1b. Monthly Word Volume
      makeChart('monthlyWordChart', {
        type: 'line',
        data: {
          labels: monthlyWords.labels,
          datasets: [
            { label: 'Total Words', data: monthlyWords.values, borderColor: '#f0883e', backgroundColor: '#f0883e22', tension: 0.3, fill: true },
            { label: '3-mo Avg', data: monthlyWordAvg, borderColor: '#79c0ff', backgroundColor: '#79c0ff22', tension: 0.3, fill: true },
          ],
        },
        options: mergeOpts({}),
      });

      // 1c. Monthly Post Count
      makeChart('postCountChart', {
        type: 'bar',
        data: {
          labels: monthlyPostCounts.labels,
          datasets: [{ label: 'Posts', data: monthlyPostCounts.values, backgroundColor: '#3fb95088', borderColor: '#3fb950', borderWidth: 1 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } } }),
      });

      // 2. Readability
      makeChart('readabilityChart', {
        type: 'line',
        data: {
          labels,
          datasets: [{ label: 'Grade Level', data: posts.map(p => p.readability), borderColor: '#3fb950', backgroundColor: '#3fb95033', fill: true, tension: 0.3 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } } }),
      });

      // 2b. Readability (Monthly Avg)
      makeChart('readabilityMonthlyChart', {
        type: 'line',
        data: {
          labels: monthlyReadability.labels,
          datasets: [{ label: 'Avg Grade Level', data: monthlyReadability.values, borderColor: '#3fb950', backgroundColor: '#3fb95022', fill: true, tension: 0.3 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } } }),
      });

      // 2c. Sentiment (Monthly Avg)
      makeChart('sentimentChart', {
        type: 'line',
        data: {
          labels: monthlySentiment.labels,
          datasets: [{ label: 'Sentiment', data: monthlySentiment.values, borderColor: '#bc8cff', backgroundColor: '#bc8cff22', fill: true, tension: 0.3 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } }, scales: { ...chartDefaults.scales, y: { ...chartDefaults.scales.y, title: { display: true, text: 'Comparative', color: '#8b949e' } } } }),
      });

      // 3. Sentence Length
      makeChart('sentenceLengthChart', {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Mean', data: posts.map(p => p.sentenceStats.mean), borderColor: '#f0883e', tension: 0.3 },
            { label: 'Mean + Stdev', data: posts.map(p => p.sentenceStats.mean + p.sentenceStats.stdev), borderColor: '#f0883e44', backgroundColor: '#f0883e11', fill: '+1', tension: 0.3 },
            { label: 'Mean - Stdev', data: posts.map(p => Math.max(0, p.sentenceStats.mean - p.sentenceStats.stdev)), borderColor: '#f0883e44', fill: false, tension: 0.3 },
          ],
        },
        options: mergeOpts({}),
      });

      // 4. Question Density
      makeChart('questionDensityChart', {
        type: 'bar',
        data: {
          labels,
          datasets: [{ label: 'Question %', data: posts.map(p => Math.round(p.questionDensity * 100)), backgroundColor: '#d2992288', borderColor: '#d29922', borderWidth: 1 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } }, scales: { ...chartDefaults.scales, y: { ...chartDefaults.scales.y, title: { display: true, text: '%', color: '#8b949e' } } } }),
      });

      // 5. List vs Prose
      makeChart('listProseChart', {
        type: 'bar',
        data: {
          labels,
          datasets: [
            { label: 'List', data: posts.map(p => Math.round(p.listProseRatio * 100)), backgroundColor: '#bc8cff88', borderColor: '#bc8cff', borderWidth: 1 },
            { label: 'Prose', data: posts.map(p => Math.round((1 - p.listProseRatio) * 100)), backgroundColor: '#79c0ff88', borderColor: '#79c0ff', borderWidth: 1 },
          ],
        },
        options: mergeOpts({ scales: { ...chartDefaults.scales, x: { ...chartDefaults.scales.x, stacked: true }, y: { ...chartDefaults.scales.y, stacked: true, max: 100, title: { display: true, text: '%', color: '#8b949e' } } } }),
      });

      // 6. Vocabulary Growth
      makeChart('vocabGrowthChart', {
        type: 'line',
        data: {
          labels: vg.map(v => shortName(v.post)),
          datasets: [
            { label: 'Cumulative Unique', data: vg.map(v => v.cumulativeUnique), borderColor: '#3fb950', tension: 0.3, yAxisID: 'y' },
            { label: 'New Words', data: vg.map(v => v.newWords), type: 'bar', backgroundColor: '#3fb95044', borderColor: '#3fb950', borderWidth: 1, yAxisID: 'y1' },
          ],
        },
        options: mergeOpts({
          scales: {
            x: chartDefaults.scales.x,
            y: { ...chartDefaults.scales.y, position: 'left', title: { display: true, text: 'Cumulative', color: '#8b949e' } },
            y1: { ...chartDefaults.scales.y, position: 'right', title: { display: true, text: 'New', color: '#8b949e' }, grid: { drawOnChartArea: false } },
          },
        }),
      });

      // 7. Named Entities
      const entityNames = Object.keys(data.global.topEntitiesOverTime).slice(0, 8);
      // Build filtered entity data: only include data points matching the year filter
      const filteredPostNames = new Set(posts.map(p => p.filename));
      makeChart('entityChart', {
        type: 'line',
        data: {
          labels,
          datasets: entityNames.map((name, i) => ({
            label: name,
            data: data.global.topEntitiesOverTime[name]
              .filter(e => filteredPostNames.has(e.post))
              .map(e => e.count),
            borderColor: COLORS[i % COLORS.length],
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 2,
          })),
        },
        options: mergeOpts({}),
      });

      // 7b. Seasonality Index
      makeChart('seasonalityChart', {
        type: 'line',
        data: {
          labels: MONTH_LABELS,
          datasets: [
            { label: 'Words/Post', data: seasonalityWords, borderColor: '#f0883e', backgroundColor: '#f0883e22', tension: 0.3, spanGaps: true },
            { label: 'Sentiment', data: seasonalitySentiment, borderColor: '#bc8cff', backgroundColor: '#bc8cff22', tension: 0.3, spanGaps: true },
            { label: 'Readability', data: seasonalityReadability, borderColor: '#3fb950', backgroundColor: '#3fb95022', tension: 0.3, spanGaps: true },
          ],
        },
        options: mergeOpts({ scales: { ...chartDefaults.scales, y: { ...chartDefaults.scales.y, title: { display: true, text: 'Index (100 = avg)', color: '#8b949e' } } } }),
      });

      // 8. Self-References
      makeChart('selfRefChart', {
        type: 'bar',
        data: {
          labels,
          datasets: [{ label: 'Self-refs', data: posts.map(p => p.selfReferences), backgroundColor: '#f8514988', borderColor: '#f85149', borderWidth: 1 }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } } }),
      });

      // 9. Days Late
      const daysLateData = posts
        .filter(p => p.date && p.postedDate)
        .map(p => {
          const coverDate = new Date(p.date);
          const endOfMonth = new Date(coverDate.getUTCFullYear(), coverDate.getUTCMonth() + 1, 0);
          const posted = new Date(p.postedDate);
          const daysLate = Math.round((posted - endOfMonth) / (1000 * 60 * 60 * 24));
          return { label: shortName(p.filename), daysLate };
        });
      makeChart('daysLateChart', {
        type: 'bar',
        data: {
          labels: daysLateData.map(d => d.label),
          datasets: [{
            label: 'Days Late',
            data: daysLateData.map(d => d.daysLate),
            backgroundColor: daysLateData.map(d => d.daysLate > 30 ? '#f8514988' : d.daysLate > 14 ? '#d2992288' : '#3fb95088'),
            borderColor: daysLateData.map(d => d.daysLate > 30 ? '#f85149' : d.daysLate > 14 ? '#d29922' : '#3fb950'),
            borderWidth: 1,
          }],
        },
        options: mergeOpts({ plugins: { legend: { display: false } } }),
      });

      // 10. Substack analytics
      const substackCards = ['deliveriesCard', 'openRateCard', 'firstOpenCard', 'subscriberCard', 'openCountriesCard'];
      if (!data.substack) {
        substackCards.forEach(id => { const card = document.getElementById(id); if (card) card.style.display = 'none'; });
      } else {
        substackCards.forEach(id => { const card = document.getElementById(id); if (card) card.style.display = ''; });
        const monthlyEntries = filterMonthEntries(data.substack.monthly, year);
        const monthLabels = monthlyEntries.map(entry => monthLabel(entry.key));
        const deliveries = monthlyEntries.map(entry => entry.value.delivered);
        const uniqueOpeners = monthlyEntries.map(entry => entry.value.uniqueOpeners);
        const openRates = monthlyEntries.map(entry => entry.value.openRate !== null ? Math.round(entry.value.openRate * 1000) / 10 : null);
        const avgOpenLag = monthlyEntries.map(entry => entry.value.avgOpenLagMinutes);

        makeChart('deliveriesChart', {
          type: 'line',
          data: {
            labels: monthLabels,
            datasets: [
              { label: 'Delivered', data: deliveries, borderColor: '#79c0ff', backgroundColor: '#79c0ff33', tension: 0.3, fill: true },
              { label: 'Unique Opens', data: uniqueOpeners, borderColor: '#3fb950', backgroundColor: '#3fb95033', tension: 0.3, fill: true },
            ],
          },
          options: mergeOpts({}),
        });

        makeChart('openRateChart', {
          type: 'line',
          data: {
            labels: monthLabels,
            datasets: [{ label: 'Open Rate %', data: openRates, borderColor: '#d29922', backgroundColor: '#d2992233', tension: 0.3, fill: true }],
          },
          options: mergeOpts({ scales: { ...chartDefaults.scales, y: { ...chartDefaults.scales.y, title: { display: true, text: '%', color: '#8b949e' }, max: 100 } } }),
        });

        makeChart('firstOpenChart', {
          type: 'line',
          data: {
            labels: monthLabels,
            datasets: [{ label: 'Minutes', data: avgOpenLag, borderColor: '#bc8cff', backgroundColor: '#bc8cff33', tension: 0.3, fill: true }],
          },
          options: mergeOpts({}),
        });

        const subscriberEntries = filterMonthEntries(data.substack.subscribers, year);
        const subscriberLabels = subscriberEntries.map(entry => monthLabel(entry.key));
        makeChart('subscriberGrowthChart', {
          type: 'line',
          data: {
            labels: subscriberLabels,
            datasets: [
              { label: 'Total Subscribers', data: subscriberEntries.map(e => e.value.total), borderColor: '#f0883e', backgroundColor: '#f0883e22', tension: 0.3, fill: true },
              { label: 'Active Subscribers', data: subscriberEntries.map(e => e.value.active), borderColor: '#58a6ff', backgroundColor: '#58a6ff22', tension: 0.3, fill: true },
            ],
          },
          options: mergeOpts({}),
        });

        const countryTotals = {};
        const postsForYear = filterByYear(Object.values(data.substack.posts), year, substackYearFromPost);
        postsForYear.forEach(post => {
          Object.entries(post.opensByCountry || {}).forEach(([country, count]) => {
            countryTotals[country] = (countryTotals[country] || 0) + count;
          });
        });
        const topCountries = Object.entries(countryTotals)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 10);
        makeChart('openCountriesChart', {
          type: 'bar',
          data: {
            labels: topCountries.map(([country]) => country),
            datasets: [{ label: 'Open Events', data: topCountries.map(([, count]) => count), backgroundColor: '#79c0ff88', borderColor: '#79c0ff', borderWidth: 1 }],
          },
          options: mergeOpts({ plugins: { legend: { display: false } }, indexAxis: 'y' }),
        });
      }

      // 11. Publication Timeline table
      const pubBody = document.querySelector('#publicationTable tbody');
      pubBody.innerHTML = '';
      let lastPosted = null;
      for (const p of posts) {
        const tr = document.createElement('tr');
        const posted = p.postedDate ? new Date(p.postedDate) : null;
        const postedStr = posted ? posted.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }) : '--';
        let daysSince = '--';
        if (posted && lastPosted) {
          daysSince = Math.round((posted - lastPosted) / (1000 * 60 * 60 * 24)).toString();
        }
        if (posted) lastPosted = posted;
        tr.innerHTML = `<td>${p.subjectLine || shortName(p.filename)}</td><td>${p.subtitle || '--'}</td><td>${postedStr}</td><td>${daysSince}</td>`;
        pubBody.appendChild(tr);
      }

      // 11. Opening Lines table
      const tbody = document.querySelector('#openingLinesTable tbody');
      tbody.innerHTML = '';
      for (const p of posts) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${p.subjectLine || shortName(p.filename)}</td><td class="opening-line" title="${p.openingLine.replace(/"/g, '&quot;')}">${p.openingLine}</td>`;
        tbody.appendChild(tr);
      }

      // 12. Broken Links table
      const linkRotCard = document.getElementById('linkRotCard');
      const rotBody = document.querySelector('#linkRotTable tbody');
      rotBody.innerHTML = '';
      if (filteredLinkRot.length > 0) {
        linkRotCard.style.display = 'block';
        for (const link of filteredLinkRot) {
          const tr = document.createElement('tr');
          const statusClass = link.status === 'error' ? 'error-text' : '';
          tr.innerHTML = `<td style="word-break:break-all; max-width:400px;">${link.url}</td><td class="${statusClass}">${link.status}</td><td>${link.source}</td>`;
          rotBody.appendChild(tr);
        }
      } else {
        linkRotCard.style.display = 'none';
      }
    }

    async function main() {
      try {
        const res = await fetch('/newsletter-analysis/analysis.json');
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        allData = await res.json();
      } catch (e) {
        document.body.innerHTML = `<div class="loading error-text">Failed to load analysis.json: ${e.message}<br>Run "bun run deep-analyze" first.</div>`;
        return;
      }

      // Year filter buttons
      function setYear(year) {
        document.querySelectorAll('.year-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`.year-btn[data-year="${year}"]`).classList.add('active');
        const url = new URL(window.location);
        if (year === 'all') { url.searchParams.delete('year'); } else { url.searchParams.set('year', year); }
        history.replaceState(null, '', url);
        render(year);
      }

      document.querySelectorAll('.year-btn').forEach(btn => {
        btn.addEventListener('click', () => setYear(btn.dataset.year));
      });

      const initialYear = new URLSearchParams(window.location.search).get('year') || 'all';
      setYear(initialYear);
    }

    main();
  </script>
</body>
</html>
